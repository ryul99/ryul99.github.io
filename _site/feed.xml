<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://ryul99.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://ryul99.github.io/" rel="alternate" type="text/html" /><updated>2020-01-03T18:42:35+09:00</updated><id>http://ryul99.github.io/feed.xml</id><title type="html">Lab of ryul99</title><subtitle>Lab for doing what ryul99 wants
</subtitle><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><entry><title type="html">Deformable Convolution paper review</title><link href="http://ryul99.github.io/2020/01/03/Deformable_Convolutional_Networks.html" rel="alternate" type="text/html" title="Deformable Convolution paper review" /><published>2020-01-03T00:00:00+09:00</published><updated>2020-01-03T00:00:00+09:00</updated><id>http://ryul99.github.io/2020/01/03/Deformable_Convolutional_Networks</id><content type="html" xml:base="http://ryul99.github.io/2020/01/03/Deformable_Convolutional_Networks.html">&lt;h1 id=&quot;deformable-convolutional-networks&quot;&gt;Deformable Convolutional Networks&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1703.06211&quot;&gt;Paper arxiv link&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;deformable-convolution&quot;&gt;Deformable Convolution&lt;/h2&gt;

&lt;p&gt;Standard convolution has fixed sampling location and receptive field. To solve this problem, Deformable convolution use learnable offset.&lt;/p&gt;

&lt;h3 id=&quot;2d-convolution&quot;&gt;2D Convolution&lt;/h3&gt;

&lt;p&gt;The standard 2D convolution consists of two steps: 1) sampling using a regular grid &lt;script type=&quot;math/tex&quot;&gt;\mathcal{R}&lt;/script&gt; over the input feature map &lt;script type=&quot;math/tex&quot;&gt;\mathbf{x}&lt;/script&gt;; 2) summation of sampled values weighted by &lt;script type=&quot;math/tex&quot;&gt;\mathbf{w}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The receptive field size and dilation define the grid &lt;script type=&quot;math/tex&quot;&gt;\mathcal{R}&lt;/script&gt;. For example, when 3 X 3 kernel with dilation 1 the grid is:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{R}=\{(-1, -1), (-1, 0), \ldots, (0,1), (1, 1)\}&lt;/script&gt;

&lt;p&gt;For each location &lt;script type=&quot;math/tex&quot;&gt;\mathbf{p}_0&lt;/script&gt; on the output feature map &lt;script type=&quot;math/tex&quot;&gt;\mathbf{y}&lt;/script&gt;, 2D convolution can be denoted as followings:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{y}(\mathbf{p}_0)=\sum_{\mathbf{p}_n\in\mathcal{R}}\mathbf{w}(\mathbf{p}_n)\cdot \mathbf{x}(\mathbf{p}_0+\mathbf{p}_n),&lt;/script&gt;

&lt;h3 id=&quot;2d-deformable-convolution&quot;&gt;2D Deformable Convolution&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Deformable_Convolutional_Networks/deform_conv_layer_v7-1.png&quot; alt=&quot;/assets/images/Deformable_Convolutional_Networks/deform_conv_layer_v7-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In deformable convolution, the regular grid &lt;script type=&quot;math/tex&quot;&gt;\mathcal{R}&lt;/script&gt; is augmented with offsets &lt;script type=&quot;math/tex&quot;&gt;\{\Delta \mathbf{p}_n \lvert n=1,...,N\}&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;N= \lvert \mathcal{R} \lvert&lt;/script&gt;. In other words, offsets can be different per grid offset. The offsets are obtained by applying a convolution layer over same input feature map, which means the offsets are learned.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{y}(\mathbf{p}_0)=\sum_{\mathbf{p}_n\in\mathcal{R}}\mathbf{w}(\mathbf{p}_n)\cdot \mathbf{x}(\mathbf{p}_0+\mathbf{p}_n+\Delta \mathbf{p}_n).&lt;/script&gt;

&lt;p&gt;Now, the sampling is on the irregular because the offset &lt;script type=&quot;math/tex&quot;&gt;\Delta \mathbf{p}_n&lt;/script&gt; is typically fractional. So &lt;script type=&quot;math/tex&quot;&gt;\mathbf{x}(\mathbf{p}_0+\mathbf{p}_n+\Delta \mathbf{p}_n)&lt;/script&gt; is implemented via bilinear interpolation as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{x}(\mathbf{p})=\sum_\mathbf{q} G(\mathbf{q},\mathbf{p})\cdot \mathbf{x}(\mathbf{q}),&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\mathbf{p}=\mathbf{p}_0+\mathbf{p}_n+\Delta \mathbf{p}_n&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mathbf{q}&lt;/script&gt; is integral positions within 2 X 2 square which is centered with &lt;script type=&quot;math/tex&quot;&gt;\mathbf{p}&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;G(\cdot,\cdot)&lt;/script&gt; is the bilinear interpolation kernel and can be denoted as follows:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;G(\mathbf{q},\mathbf{p})=(1- \lvert q_x-p_x \lvert ) \cdot (1- \lvert q_y-p_y \lvert )&lt;/script&gt;

&lt;h2 id=&quot;result&quot;&gt;Result&lt;/h2&gt;

&lt;p&gt;As Deformable convolution has offset on its grid, It can have more flexible receptive field.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Standard Convolution&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Deformable Convolution&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/images/Deformable_Convolutional_Networks/standard_conv_receptive_field_v6-1.png&quot; alt=&quot;/assets/images/Deformable_Convolutional_Networks/standard_conv_receptive_field_v6-1.png&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;/assets/images/Deformable_Convolutional_Networks/deform_conv_receptive_field_v6-1.png&quot; alt=&quot;/assets/images/Deformable_Convolutional_Networks/deform_conv_receptive_field_v6-1.png&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="paper" /><category term="review" /><category term="DeepLearning" /><summary type="html">Deformable Convolutional Networks Paper arxiv link Deformable Convolution Standard convolution has fixed sampling location and receptive field. To solve this problem, Deformable convolution use learnable offset. 2D Convolution The standard 2D convolution consists of two steps: 1) sampling using a regular grid over the input feature map ; 2) summation of sampled values weighted by . The receptive field size and dilation define the grid . For example, when 3 X 3 kernel with dilation 1 the grid is: For each location on the output feature map , 2D convolution can be denoted as followings: 2D Deformable Convolution In deformable convolution, the regular grid is augmented with offsets , where . In other words, offsets can be different per grid offset. The offsets are obtained by applying a convolution layer over same input feature map, which means the offsets are learned. Now, the sampling is on the irregular because the offset is typically fractional. So is implemented via bilinear interpolation as where and is integral positions within 2 X 2 square which is centered with . is the bilinear interpolation kernel and can be denoted as follows: Result As Deformable convolution has offset on its grid, It can have more flexible receptive field. Standard Convolution Deformable Convolution</summary></entry><entry><title type="html">EDVR paper review</title><link href="http://ryul99.github.io/2019/12/24/EDVR_paper_review.html" rel="alternate" type="text/html" title="EDVR paper review" /><published>2019-12-24T00:00:00+09:00</published><updated>2019-12-24T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/12/24/EDVR_paper_review</id><content type="html" xml:base="http://ryul99.github.io/2019/12/24/EDVR_paper_review.html">&lt;h1 id=&quot;edvr-video-restoration-with-enhanced-deformable-convolutional-networks&quot;&gt;EDVR: Video Restoration with Enhanced Deformable Convolutional Networks&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1905.02716&quot;&gt;Paper arxiv link&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;h2 id=&quot;the-overall-framework-of-edvr&quot;&gt;The overall framework of EDVR&lt;/h2&gt;
&lt;p&gt;Given &lt;script type=&quot;math/tex&quot;&gt;2N+1&lt;/script&gt; consecutive frames &lt;script type=&quot;math/tex&quot;&gt;I_{[t-N:t+N]}&lt;/script&gt;, denote middle frame &lt;script type=&quot;math/tex&quot;&gt;I_{t}&lt;/script&gt; as the reference frame and the other frames as neighboring frames&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/EDVR_paper_review/overall_structure-1.png&quot; alt=&quot;/assets/images/EDVR_paper_review/overall_structure-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Inputs with high spatial resolution are first down-sampled to reduce computational cost. Given blurry inputs, a PreDeblur Module is inserted before the PCD Align Module to improve alignment accuracy. We use three input frames as an illustrative example.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Downsampling &amp;amp; Upsampling:&lt;/p&gt;

    &lt;p&gt;If task is not Super Resolution with high spatial resolution inputs, input frames are first downsampled with strided convolution layers.&lt;/p&gt;

    &lt;p&gt;Resize the features back to the original input resolution in the upsampling layer at the end.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PreDeblur:&lt;/p&gt;

    &lt;p&gt;This is used before the alignment module to pre-process blurry inputs and improve alignment accuracy.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PCD:&lt;/p&gt;

    &lt;p&gt;Each neighboring frame is aligned to the reference one by the PCD alignment module at the feature level.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TSA:&lt;/p&gt;

    &lt;p&gt;The TSA fusion module fuses image information of different frames.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reconstruction Module:&lt;/p&gt;

    &lt;p&gt;The fused features then pass through a reconstruction module, which is a cascade of residual blocks in EDVR and can be easily replaced by any other advanced modules in single image SR.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Residual at the end:&lt;/p&gt;

    &lt;p&gt;High-resolution frame is obtained by adding the predicted image residual to a direct upsampled image (Super Resolution).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Two-stage strategy:&lt;/p&gt;

    &lt;p&gt;Cascade the same EDVR network but with shallower depth to refine the output frames of the first stage.&lt;/p&gt;

    &lt;p&gt;The cascaded network can further remove the severe motion blur.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;alignment-with-pyramid-cascading-and-deformable-convolution-pcd&quot;&gt;Alignment with Pyramid, Cascading and Deformable Convolution (PCD)&lt;/h1&gt;

&lt;h2 id=&quot;use-of-deformable-convolution&quot;&gt;Use of Deformable Convolution&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Alignment features of each neighboring frame to reference frame.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Different from optical-flow based method, deformable alignment is applied on the features of each frame, denote by &lt;script type=&quot;math/tex&quot;&gt;F_{t+i},i \in [{-}N{:}{+}N]&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Learnable offset (&lt;script type=&quot;math/tex&quot;&gt;\Delta \mathbf{P}_{t+i}&lt;/script&gt;) of Deformable Convolution is predicted as &lt;script type=&quot;math/tex&quot;&gt;f(\ [F_{t+i}, F_t]\ )&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is general function consisting several convolution layers and &lt;script type=&quot;math/tex&quot;&gt;[F_{t+i}, F_t]&lt;/script&gt; is concat of two feature &lt;script type=&quot;math/tex&quot;&gt;F_{t+i}, F_t&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pyramidal-processing-and-cascading-refinement&quot;&gt;Pyramidal processing and Cascading refinement&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/EDVR_paper_review/pcd_align-1.png&quot; alt=&quot;/assets/images/EDVR_paper_review/pcd_align-1.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Black dash lines:
    &lt;ul&gt;
      &lt;li&gt;To generate feature F in l-th level, strided convolution filters are used to downsample the features at the (l-1)-th pyramid level by factor of 2.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Orange lines:
    &lt;ul&gt;
      &lt;li&gt;Concat reference frame with neighboring frame.&lt;/li&gt;
      &lt;li&gt;The offset is made by convolution with concatenation.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Purple dash lines:
    &lt;ul&gt;
      &lt;li&gt;At the l-th level, offsets and aligned features are predicted also with X2 bilinear-interpolation-upsampled offsets and aligned features from the upper (l+1)-th level, respectively&lt;/li&gt;
      &lt;li&gt;Output of Deformable Conv (blue line) and upsampled (l+1)-th level (purple dash lines) are mixed by general function with several convolution layers&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Light purple background:
    &lt;ul&gt;
      &lt;li&gt;Following the pyramid structure, a subsequent deformable alignment is cascaded to further refine the coarsely aligned features.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;fusion-with-temporoal-and-spatial-attention&quot;&gt;Fusion with Temporoal and Spatial Attention&lt;/h1&gt;

&lt;p&gt;Inter-frame temporal relation and intra-frame spatial relation are critical in fusion because&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;different neighboring frames are not equally informative due to occlusion, blurry regions and parallax problems&lt;/li&gt;
  &lt;li&gt;misalignment and unalignment arising from the preceding alignment stage adversely affect the subsequent reconstruction performance&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;→ Temporal and spatial attentions during the fusion process is adopted&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/EDVR_paper_review/tsa_fusion-1.png&quot; alt=&quot;/assets/images/EDVR_paper_review/tsa_fusion-1.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Temporal Attention Maps: blue, red, green object of top left.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;F_{t}^{fusion} = \text{Conv}([\text{concat of attention-weighted features from t-N to t+N}])&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="paper" /><category term="review" /><category term="DeepLearning" /><summary type="html">EDVR: Video Restoration with Enhanced Deformable Convolutional Networks Paper arxiv link Overview The overall framework of EDVR Given consecutive frames , denote middle frame as the reference frame and the other frames as neighboring frames Inputs with high spatial resolution are first down-sampled to reduce computational cost. Given blurry inputs, a PreDeblur Module is inserted before the PCD Align Module to improve alignment accuracy. We use three input frames as an illustrative example. Downsampling &amp;amp; Upsampling: If task is not Super Resolution with high spatial resolution inputs, input frames are first downsampled with strided convolution layers. Resize the features back to the original input resolution in the upsampling layer at the end. PreDeblur: This is used before the alignment module to pre-process blurry inputs and improve alignment accuracy. PCD: Each neighboring frame is aligned to the reference one by the PCD alignment module at the feature level. TSA: The TSA fusion module fuses image information of different frames. Reconstruction Module: The fused features then pass through a reconstruction module, which is a cascade of residual blocks in EDVR and can be easily replaced by any other advanced modules in single image SR. Residual at the end: High-resolution frame is obtained by adding the predicted image residual to a direct upsampled image (Super Resolution). Two-stage strategy: Cascade the same EDVR network but with shallower depth to refine the output frames of the first stage. The cascaded network can further remove the severe motion blur. Alignment with Pyramid, Cascading and Deformable Convolution (PCD) Use of Deformable Convolution Alignment features of each neighboring frame to reference frame. Different from optical-flow based method, deformable alignment is applied on the features of each frame, denote by Learnable offset () of Deformable Convolution is predicted as , where is general function consisting several convolution layers and is concat of two feature . Pyramidal processing and Cascading refinement Black dash lines: To generate feature F in l-th level, strided convolution filters are used to downsample the features at the (l-1)-th pyramid level by factor of 2. Orange lines: Concat reference frame with neighboring frame. The offset is made by convolution with concatenation. Purple dash lines: At the l-th level, offsets and aligned features are predicted also with X2 bilinear-interpolation-upsampled offsets and aligned features from the upper (l+1)-th level, respectively Output of Deformable Conv (blue line) and upsampled (l+1)-th level (purple dash lines) are mixed by general function with several convolution layers Light purple background: Following the pyramid structure, a subsequent deformable alignment is cascaded to further refine the coarsely aligned features. Fusion with Temporoal and Spatial Attention Inter-frame temporal relation and intra-frame spatial relation are critical in fusion because different neighboring frames are not equally informative due to occlusion, blurry regions and parallax problems misalignment and unalignment arising from the preceding alignment stage adversely affect the subsequent reconstruction performance → Temporal and spatial attentions during the fusion process is adopted Temporal Attention Maps: blue, red, green object of top left.</summary></entry><entry><title type="html">Difference of locals, globals, vars in python3</title><link href="http://ryul99.github.io/2019/12/13/python_locals-globals-vars.html" rel="alternate" type="text/html" title="Difference of locals, globals, vars in python3" /><published>2019-12-13T00:00:00+09:00</published><updated>2019-12-13T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/12/13/python_locals-globals-vars</id><content type="html" xml:base="http://ryul99.github.io/2019/12/13/python_locals-globals-vars.html">&lt;p&gt;reference: &lt;a href=&quot;https://stackoverflow.com/a/7969953&quot;&gt;https://stackoverflow.com/a/7969953&lt;/a&gt;&lt;br /&gt;
부족한 영어실력으로 해석해서 정리한 글입니다. 오류가 있을 경우 지적해주세요.&lt;/p&gt;

&lt;h1 id=&quot;파이썬-globals-locals-vars의-차이&quot;&gt;파이썬 globals, locals, vars의 차이&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;globals()
    &lt;ul&gt;
      &lt;li&gt;module의 namespace의 dic이를 return한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;locals()
    &lt;ul&gt;
      &lt;li&gt;함수 안에서는 함수의 locals()를 호출한 순간의 namespace의 dict - 실제 namespace를 reflect하지 않음&lt;/li&gt;
      &lt;li&gt;함수 밖에서는 현재의 namespace의 dict - 실제 namespace를 reflect함&lt;/li&gt;
      &lt;li&gt;함수 안에서 locals()가 호출한 순간의 namespace를 들고오고 reflect 하지 않는다는 것은 CPython specific&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;vars()
    &lt;ul&gt;
      &lt;li&gt;인자로 object를 받는데 받은 object의 __dict__를 부르고 이게 없을 경우 그 object의 namespace를 return&lt;/li&gt;
      &lt;li&gt;인자 없이 사용하는 vars()는 locals()랑 같다&lt;/li&gt;
      &lt;li&gt;vars()의 인자로 function을 줄 수 있는데 이 경우도 object로 봐서 function.__dict__를 부르거나 없다면 function의 object의 namespace를 부른다. function의 namespace와 다르게 function object의 namespace임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="python" /><summary type="html">reference: https://stackoverflow.com/a/7969953 부족한 영어실력으로 해석해서 정리한 글입니다. 오류가 있을 경우 지적해주세요. 파이썬 globals, locals, vars의 차이 globals() module의 namespace의 dic이를 return한다. locals() 함수 안에서는 함수의 locals()를 호출한 순간의 namespace의 dict - 실제 namespace를 reflect하지 않음 함수 밖에서는 현재의 namespace의 dict - 실제 namespace를 reflect함 함수 안에서 locals()가 호출한 순간의 namespace를 들고오고 reflect 하지 않는다는 것은 CPython specific vars() 인자로 object를 받는데 받은 object의 __dict__를 부르고 이게 없을 경우 그 object의 namespace를 return 인자 없이 사용하는 vars()는 locals()랑 같다 vars()의 인자로 function을 줄 수 있는데 이 경우도 object로 봐서 function.__dict__를 부르거나 없다면 function의 object의 namespace를 부른다. function의 namespace와 다르게 function object의 namespace임</summary></entry><entry><title type="html">Run dev-server with Google Cloud Shell</title><link href="http://ryul99.github.io/2019/10/22/ghpage_devserver_with_Google-Cloud-Shell.html" rel="alternate" type="text/html" title="Run dev-server with Google Cloud Shell" /><published>2019-10-22T00:00:00+09:00</published><updated>2019-10-22T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/10/22/ghpage_devserver_with_Google-Cloud-Shell</id><content type="html" xml:base="http://ryul99.github.io/2019/10/22/ghpage_devserver_with_Google-Cloud-Shell.html">&lt;p&gt;github page를 블로그로 사용하면서 불편했던 것 중 하나는 네이버, 티스토리 블로그등과는 다르게 웹 브라우저에서 블로그 글을 수정하거나 새롭게 적는 것이 안된다는 점이었습니다. 
또한 블로그에 수정이 필요할 때마다 로컬에 빌드 환경을 구축해야 했고 로컬의 환경이 달라짐에 따라 빌드가 안되는 경우도 종종 생겼습니다. 
그래서 제가 찾아보았던 방법은 클라우드 서비스에 블로그 소스코드와 빌드 환경을 구축하고 여기에 접속해서 블로그 글을 작성하고 수정하는 방식으로 로컬 환경의 제약없이 블로그를 빌드하는 것이었습니다.
그러던 중 제가 찾은 완벽한 대안은 Google Cloud Platform에서 제공하는 Google Cloud Shell입니다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;google-cloud-shell의-특징&quot;&gt;Google Cloud Shell의 특징&lt;/h1&gt;
&lt;p&gt;Google Cloud Shell은 다양한 특징이 있는 데 제가 중점적으로 끌렸던 특징을 모아봤습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹 브라우저에서 인스턴스에 대한 명령줄 액세스&lt;/li&gt;
  &lt;li&gt;코드 편집기(베타) 기본 제공&lt;/li&gt;
  &lt;li&gt;5GB의 영구 디스크 저장소&lt;/li&gt;
  &lt;li&gt;사전 설치된 Google Cloud SDK 및 기타 도구&lt;/li&gt;
  &lt;li&gt;자바, Go, Python, Node.js, PHP, Ruby, .NET과 같은 언어 지원&lt;/li&gt;
  &lt;li&gt;웹 미리보기 기능&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여기서 특히 좋은 것은 인스턴스에서 개발서버를 열었을 때 웹 미리보기가 가능한 점, 웹 브라우저에서 인스턴스에 대한 명령줄 액세스가 가능한 점, 웹 브라우저 상에서 코드 편집기를 제공하는 점이었습니다.
웹 브라우저에서 게시글의 수정, 빌드가 가능하고 deploy하기 전 잘 보이는 지 확인까지 별다른 설정없이 가능하기에, 네이버 / 티스토리 블로그 같이 웹 브라우저에서 모든 블로그 관리가 가능해졌습니다.&lt;br /&gt;
다만 조심해야 할 점은 이 인스턴스는 일시적으로 사용이 가능하다는 점입니다. 홈디렉토리를 제외하면 인스턴스는 일정시간 후에 삭제됩니다.
&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;시작하기&quot;&gt;시작하기&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://ssh.cloud.google.com/cloudshell&quot;&gt;https://ssh.cloud.google.com/cloudshell&lt;/a&gt;에 접속하셔서 사용하실 수 있습니다.&lt;br /&gt;
웹 미리보기의 경우 아래 사진의 연필 모양(편집기 모양) 오른쪽에 있는 아이콘입니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/Google-Cloud-Platform/startcloudshell2.png&quot; title=&quot;GCP control bar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a href=&quot;https://cloud.google.com/shell/docs/&quot;&gt;공식문서&lt;/a&gt;를 참고하시면 더 좋을 듯 합니다.&lt;/p&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="github" /><category term="GCP" /><summary type="html">github page를 블로그로 사용하면서 불편했던 것 중 하나는 네이버, 티스토리 블로그등과는 다르게 웹 브라우저에서 블로그 글을 수정하거나 새롭게 적는 것이 안된다는 점이었습니다. 또한 블로그에 수정이 필요할 때마다 로컬에 빌드 환경을 구축해야 했고 로컬의 환경이 달라짐에 따라 빌드가 안되는 경우도 종종 생겼습니다. 그래서 제가 찾아보았던 방법은 클라우드 서비스에 블로그 소스코드와 빌드 환경을 구축하고 여기에 접속해서 블로그 글을 작성하고 수정하는 방식으로 로컬 환경의 제약없이 블로그를 빌드하는 것이었습니다. 그러던 중 제가 찾은 완벽한 대안은 Google Cloud Platform에서 제공하는 Google Cloud Shell입니다. Google Cloud Shell의 특징 Google Cloud Shell은 다양한 특징이 있는 데 제가 중점적으로 끌렸던 특징을 모아봤습니다. 웹 브라우저에서 인스턴스에 대한 명령줄 액세스 코드 편집기(베타) 기본 제공 5GB의 영구 디스크 저장소 사전 설치된 Google Cloud SDK 및 기타 도구 자바, Go, Python, Node.js, PHP, Ruby, .NET과 같은 언어 지원 웹 미리보기 기능 여기서 특히 좋은 것은 인스턴스에서 개발서버를 열었을 때 웹 미리보기가 가능한 점, 웹 브라우저에서 인스턴스에 대한 명령줄 액세스가 가능한 점, 웹 브라우저 상에서 코드 편집기를 제공하는 점이었습니다. 웹 브라우저에서 게시글의 수정, 빌드가 가능하고 deploy하기 전 잘 보이는 지 확인까지 별다른 설정없이 가능하기에, 네이버 / 티스토리 블로그 같이 웹 브라우저에서 모든 블로그 관리가 가능해졌습니다. 다만 조심해야 할 점은 이 인스턴스는 일시적으로 사용이 가능하다는 점입니다. 홈디렉토리를 제외하면 인스턴스는 일정시간 후에 삭제됩니다. 시작하기 https://ssh.cloud.google.com/cloudshell에 접속하셔서 사용하실 수 있습니다. 웹 미리보기의 경우 아래 사진의 연필 모양(편집기 모양) 오른쪽에 있는 아이콘입니다. 공식문서를 참고하시면 더 좋을 듯 합니다.</summary></entry><entry><title type="html">Jekyll Trouble Shooting</title><link href="http://ryul99.github.io/2019/09/26/Jekyll-trouble-shooting.html" rel="alternate" type="text/html" title="Jekyll Trouble Shooting" /><published>2019-09-26T00:00:00+09:00</published><updated>2019-09-26T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/09/26/Jekyll-trouble-shooting</id><content type="html" xml:base="http://ryul99.github.io/2019/09/26/Jekyll-trouble-shooting.html">&lt;p&gt;깃헙 페이지를 위해 Jekyll을 사용하면서 겪었던 trouble shooting들을 정리해본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;윈도우에서 한글 카테고리의 포스트가 포스트 목록에는 보이지만 링크를 눌렀을 때 포스트에 접속이 안되고 Not Found가 뜨는 경우
    &lt;ul&gt;
      &lt;li&gt;윈도우용 루비를 설치해서 Jekyll을 사용하면 url에 한글이 들어갈 경우 한글이 깨지기 때문에 url에 한글이 들어가는 페이지는 들어갈 수 없다.인코딩 설정을 해서 해결할 수 있어 보이는데 나는 그냥 WSL을 사용했다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;포스트 링크를 통해서는 들어갈 수 있는데 페이지 목록에 뜨지 않는 경우 등의 플러그인 작동 오류
    &lt;ul&gt;
      &lt;li&gt;Jekyll 3.5부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;gems&lt;/code&gt;키워드가 &lt;code class=&quot;highlighter-rouge&quot;&gt;plugins&lt;/code&gt;로 바뀌었다. Jekyll 4.0.0에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;gems&lt;/code&gt;로 되어 있는 경우 인식을 못해 플러그인들이 동작하지 않았다. &lt;a href=&quot;https://jekyllrb.com/news/releases/&quot;&gt;지킬 릴리즈 참조&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="Jekyll" /><summary type="html">깃헙 페이지를 위해 Jekyll을 사용하면서 겪었던 trouble shooting들을 정리해본다. 윈도우에서 한글 카테고리의 포스트가 포스트 목록에는 보이지만 링크를 눌렀을 때 포스트에 접속이 안되고 Not Found가 뜨는 경우 윈도우용 루비를 설치해서 Jekyll을 사용하면 url에 한글이 들어갈 경우 한글이 깨지기 때문에 url에 한글이 들어가는 페이지는 들어갈 수 없다.인코딩 설정을 해서 해결할 수 있어 보이는데 나는 그냥 WSL을 사용했다. 포스트 링크를 통해서는 들어갈 수 있는데 페이지 목록에 뜨지 않는 경우 등의 플러그인 작동 오류 Jekyll 3.5부터 _config.yml에 있는 gems키워드가 plugins로 바뀌었다. Jekyll 4.0.0에서는 gems로 되어 있는 경우 인식을 못해 플러그인들이 동작하지 않았다. 지킬 릴리즈 참조</summary></entry><entry><title type="html">Linux cgroups에 대해 알아보자 2</title><link href="http://ryul99.github.io/2019/06/20/cgroups-2.html" rel="alternate" type="text/html" title="Linux cgroups에 대해 알아보자 2" /><published>2019-06-20T00:00:00+09:00</published><updated>2019-06-20T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/06/20/cgroups-2</id><content type="html" xml:base="http://ryul99.github.io/2019/06/20/cgroups-2.html">&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/category/삽질/cgroups-1/&quot;&gt;Linux cgroups에 대해 알아보자 1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/category/삽질/cgroups-2/&quot;&gt;Linux cgroups에 대해 알아보자 2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;/category/삽질/cgroups-1/&quot;&gt;지난 포스트&lt;/a&gt;에서 cgroups이 어떤 것이고 기본적으로 어떻게 사용하면 되는지 알아보았습니다. 이번 글에서는 실제로 어떻게 적용할 수 있는지 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;systemd&quot;&gt;systemd&lt;/h1&gt;
&lt;p&gt;cgroups는 기본적으로 systemd에 적용할 수 있습니다. 하지만 제가 필요했던 제한은 유저에게 가해지는 제한이었기 때문에 systemd 유닛에 제한을 가하는 방법은 사용해보지 않았습니다. 자세한 방법은 &lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/sec-modifying_control_groups&quot;&gt;redhat 7의 관련 문서&lt;/a&gt; 혹은 아래의 reference에서 redhat7 부분을 참고하시면 좋을 듯합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;libcgroup&quot;&gt;libcgroup&lt;/h1&gt;
&lt;p&gt;이 친구는 따로 설치를 해줘야 합니다. OS에 맞게 설치를 진행하시면 됩니다. 저의 경우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;centos: &lt;code class=&quot;highlighter-rouge&quot;&gt;yum install libcgroup libcgroup-tools&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;ubuntu: &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get install cgroup-bin cgroup-lite libcgroup1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로 설치했습니다.
libcgroup은 다양한 기능이 있지만 이번에 살펴볼 것은 &lt;code class=&quot;highlighter-rouge&quot;&gt;cgconfig.conf&lt;/code&gt; 작성법입니다. 이 파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cgconfig.conf&lt;/code&gt;에 있으며 이 파일을 보고 libcgroup이 cgroup을 생성하는 방식입니다. 파일 작성법은 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cgroups-2/image1.png&quot; title=&quot;cgconfig.conf&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;controller&amp;gt;&lt;/code&gt;부분은 subsystem을 적어주면 됩니다. RHEL 7 기준 default subsystem들은 이미 &lt;code class=&quot;highlighter-rouge&quot;&gt;/sys/fs/cgroup/&amp;lt;controller_name&amp;gt;&lt;/code&gt;에 마운트 되어 있습니다. 따라서 맨 윗 블록인 mount블록은 작성을 하지 않아도 됩니다. &lt;br /&gt; perm부분은 name이라는 cgroup의 권한을 설정하는 부분입니다. 생략해도 상관없으며 task에 있는 유저들은 task를 추가, 삭제할 수 있고 admin에 있는 유저들은 cgroup설정을 변경 가능합니다. &lt;br /&gt; 마지막으로 원하는 subsystem을 적어준 뒤 &lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/ch-subsystems_and_tunable_parameters&quot;&gt;이곳&lt;/a&gt;에 있는 subsystem들의 parameter를 원하는 것만 설정해주면 됩니다. &lt;br /&gt; 마지막으로 수정 후에는 cgconfig service를 재시작 해야 합니다.(systemctl restart &lt;서비스 이름=&quot;&quot;&gt;). 서비스 이름은 OS별로 다를 수 있습니다. 실제 예시는 다음과 같습니다.&lt;/서비스&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cgroups-2/image2.png&quot; title=&quot;cgconfig.conf-example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;cgred&quot;&gt;cgred&lt;/h1&gt;
&lt;p&gt;cgred는 만들어진 제한 정책을 유저, 혹은 유저그룹단위로 적용할 수 있게 합니다. 즉, 특정 유저그룹의 모든 혹은 특정 프로세스를 원하는 cgroup에 속하도록 하는 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cgrules.conf&lt;/code&gt;에 configure파일을 작성해주면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cgroups-2/image3.png&quot; title=&quot;cgrules.conf-example&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞에서부터 user / subsystems / cgroup 순으로 작성하면 되고 매칭은 맨 윗줄부터 매칭해서 할당됩니다. user자리의 경우 앞에 @가 붙으면 user group이 됩니다. subsystem에서 *의 경우 모든 subsystem을 의미합니다. %는 윗 줄의 item과 똑같다를 의미합니다. 마찬가지로 수정 후 cgred service를 재시작해야 합니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt&quot;&gt;kernel.org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/index&quot;&gt;redhat 7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index&quot;&gt;redhat 6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="Linux" /><category term="cgroups" /><summary type="html">목차 Linux cgroups에 대해 알아보자 1 Linux cgroups에 대해 알아보자 2 지난 포스트에서 cgroups이 어떤 것이고 기본적으로 어떻게 사용하면 되는지 알아보았습니다. 이번 글에서는 실제로 어떻게 적용할 수 있는지 알아보도록 하겠습니다. systemd cgroups는 기본적으로 systemd에 적용할 수 있습니다. 하지만 제가 필요했던 제한은 유저에게 가해지는 제한이었기 때문에 systemd 유닛에 제한을 가하는 방법은 사용해보지 않았습니다. 자세한 방법은 redhat 7의 관련 문서 혹은 아래의 reference에서 redhat7 부분을 참고하시면 좋을 듯합니다. libcgroup 이 친구는 따로 설치를 해줘야 합니다. OS에 맞게 설치를 진행하시면 됩니다. 저의 경우 centos: yum install libcgroup libcgroup-tools ubuntu: apt-get install cgroup-bin cgroup-lite libcgroup1 로 설치했습니다. libcgroup은 다양한 기능이 있지만 이번에 살펴볼 것은 cgconfig.conf 작성법입니다. 이 파일은 /etc/cgconfig.conf에 있으며 이 파일을 보고 libcgroup이 cgroup을 생성하는 방식입니다. 파일 작성법은 다음과 같습니다. &amp;lt;controller&amp;gt;부분은 subsystem을 적어주면 됩니다. RHEL 7 기준 default subsystem들은 이미 /sys/fs/cgroup/&amp;lt;controller_name&amp;gt;에 마운트 되어 있습니다. 따라서 맨 윗 블록인 mount블록은 작성을 하지 않아도 됩니다. perm부분은 name이라는 cgroup의 권한을 설정하는 부분입니다. 생략해도 상관없으며 task에 있는 유저들은 task를 추가, 삭제할 수 있고 admin에 있는 유저들은 cgroup설정을 변경 가능합니다. 마지막으로 원하는 subsystem을 적어준 뒤 이곳에 있는 subsystem들의 parameter를 원하는 것만 설정해주면 됩니다. 마지막으로 수정 후에는 cgconfig service를 재시작 해야 합니다.(systemctl restart ). 서비스 이름은 OS별로 다를 수 있습니다. 실제 예시는 다음과 같습니다. cgred cgred는 만들어진 제한 정책을 유저, 혹은 유저그룹단위로 적용할 수 있게 합니다. 즉, 특정 유저그룹의 모든 혹은 특정 프로세스를 원하는 cgroup에 속하도록 하는 것입니다. /etc/cgrules.conf에 configure파일을 작성해주면 됩니다. 앞에서부터 user / subsystems / cgroup 순으로 작성하면 되고 매칭은 맨 윗줄부터 매칭해서 할당됩니다. user자리의 경우 앞에 @가 붙으면 user group이 됩니다. subsystem에서 *의 경우 모든 subsystem을 의미합니다. %는 윗 줄의 item과 똑같다를 의미합니다. 마찬가지로 수정 후 cgred service를 재시작해야 합니다. Reference kernel.org redhat 7 redhat 6</summary></entry><entry><title type="html">Linux cgroups에 대해 알아보자 1</title><link href="http://ryul99.github.io/2019/06/18/cgroups-1.html" rel="alternate" type="text/html" title="Linux cgroups에 대해 알아보자 1" /><published>2019-06-18T00:00:00+09:00</published><updated>2019-06-18T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/06/18/cgroups-1</id><content type="html" xml:base="http://ryul99.github.io/2019/06/18/cgroups-1.html">&lt;h3 id=&quot;목차&quot;&gt;목차&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;/category/삽질/cgroups-1/&quot;&gt;Linux cgroups에 대해 알아보자 1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/category/삽질/cgroups-2/&quot;&gt;Linux cgroups에 대해 알아보자 2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;cgroups&quot;&gt;cgroups?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cgroups&quot;&gt;위키피디아&lt;/a&gt;에서는 cgroups가 다음과 같이 설명되어 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;cgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, &lt;strong&gt;프로세스 모음&lt;/strong&gt;에 대해 시스템의 자원을 제한할 수 있는 커널의 기능입니다. 때문에 cgroups는 하나의 프로세스에 대해 제한을 가하는 ulimit와는 다릅니다. cgroups에는 2007년부터 있던 cgroups v1이 있고 커널 4.5에서 처음 등장한 cgroups v2가 있습니다. 이 글에서 다룰 cgroups는 v1입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;주요-용어&quot;&gt;주요 용어&lt;/h1&gt;
&lt;p&gt;cgroups에서 사용되는 주요 단어들이 있습니다. 아래의 설명은 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt&quot;&gt;kernel.org&lt;/a&gt;의 설명을 번역한 것입니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;cgroup&lt;/strong&gt;: task의 집합과 하나 이상의 subsystem들의 parameters 집합이 서로 연관된 형태입니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;subsystem&lt;/strong&gt;: 묶어진 cgroup의 task들을 특정한 형태로 사용하는 모듈입니다. 여기서는 resource controller로서 cgroup당 자원을 관리하는 모듈입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;lssubsys -am&lt;/code&gt;명령어를 통해 종류와 마운트 지점을 알 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;hierarchy&lt;/strong&gt;: 트리 형태로 구성된 cgroup들의 집합입니다. 시스템의 모든 task는 hierarchy 상의 하나의 cgroup에 존재합니다. 가상의 파일시스템으로 구성되어 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;cgroups는 process와 유사하게 1. 계층적이고, 2. child가 parent로부터 특정 attributes를 상속받습니다. 하지만 process는 init프로세스를 root로 하는 거대한 하나의 트리지만 cgroups는 하나 이상의 분리된 hierarchy를 가집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;규칙&quot;&gt;규칙&lt;/h1&gt;
&lt;p&gt;cgroups에는 규칙이 4가지 있습니다. 각 규칙은 다음과 같습니다.&lt;/p&gt;

&lt;h3 id=&quot;규칙-1&quot;&gt;규칙 1&lt;/h3&gt;
&lt;p&gt;각 hierarchy는 하나 이상의 subsystem들을 가질 수 있습니다. 
&lt;img src=&quot;/assets/images/cgroups-1/image1.png&quot; title=&quot;Rule 1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;규칙-2&quot;&gt;규칙 2&lt;/h3&gt;
&lt;p&gt;한 subsystem이 연결하려는 hierarchy들이 이미 다른 subsystem을 가지고 있다면 둘 이상의 다른 hierarchy에 연결할 수 없습니다.(그 중 하나에만 연결할 수 있습니다.) 하지만 연결하려는 hierarchy들이 subsystem으로 자신 하나만 가진다면 여러 hierarchy에 연결할 수 있습니다.
&lt;img src=&quot;/assets/images/cgroups-1/image2.png&quot; title=&quot;Rule 2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;규칙-3&quot;&gt;규칙 3&lt;/h3&gt;
&lt;p&gt;각 task들은 여러 cgroup에 속할 수 있지만 한 hierarchy 내에서는 하나의 cgroup에만 속해야 합니다. 또한 모든 system task는 항상 적어도 하나의 cgroup에 속합니다.
&lt;img src=&quot;/assets/images/cgroups-1/image3.png&quot; title=&quot;Rule 3&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;규칙-4&quot;&gt;규칙 4&lt;/h3&gt;
&lt;p&gt;항상 child task는 parent task의 cgroup을 상속받아 초기화됩니다. 하지만 parent와 child는 독립적이기 때문에 이후에 바뀔 수 있습니다.
&lt;img src=&quot;/assets/images/cgroups-1/image4.png&quot; title=&quot;Rule 4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;기본적인-사용법&quot;&gt;기본적인 사용법&lt;/h1&gt;
&lt;p&gt;가장 기본적인 사용법은 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mount -t tmpfs &amp;lt;cgroup_root&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt;: cgroup_root라는 이름으로 path를 tmpfs마운트 합니다. 이곳이 hierarchy들을 담을 장소가 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mount -t cgroup -o &amp;lt;comma_separated_subsystem_names&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt;: path에 subsystem들을 마운트합니다. path폴더가 하나의 cgroup이 됩니다.&lt;/li&gt;
  &lt;li&gt;cgroup의 폴더 안에 있는 파일 중 task파일 안에 원하는 프로세스 PID를 적어주면 됩니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;하지만 이런 방법으로는 실제 사용하기가 매우 힘듭니다. 다음 게시글에서 실제 사용법을 알아보겠습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt&quot;&gt;kernel.org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/index&quot;&gt;redhat 7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/resource_management_guide/index&quot;&gt;redhat 6&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="Linux" /><category term="cgroups" /><summary type="html">목차 Linux cgroups에 대해 알아보자 1 Linux cgroups에 대해 알아보자 2 cgroups? 위키피디아에서는 cgroups가 다음과 같이 설명되어 있습니다. cgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes. 즉, 프로세스 모음에 대해 시스템의 자원을 제한할 수 있는 커널의 기능입니다. 때문에 cgroups는 하나의 프로세스에 대해 제한을 가하는 ulimit와는 다릅니다. cgroups에는 2007년부터 있던 cgroups v1이 있고 커널 4.5에서 처음 등장한 cgroups v2가 있습니다. 이 글에서 다룰 cgroups는 v1입니다. 주요 용어 cgroups에서 사용되는 주요 단어들이 있습니다. 아래의 설명은 kernel.org의 설명을 번역한 것입니다. cgroup: task의 집합과 하나 이상의 subsystem들의 parameters 집합이 서로 연관된 형태입니다. subsystem: 묶어진 cgroup의 task들을 특정한 형태로 사용하는 모듈입니다. 여기서는 resource controller로서 cgroup당 자원을 관리하는 모듈입니다. lssubsys -am명령어를 통해 종류와 마운트 지점을 알 수 있습니다. hierarchy: 트리 형태로 구성된 cgroup들의 집합입니다. 시스템의 모든 task는 hierarchy 상의 하나의 cgroup에 존재합니다. 가상의 파일시스템으로 구성되어 있습니다. cgroups는 process와 유사하게 1. 계층적이고, 2. child가 parent로부터 특정 attributes를 상속받습니다. 하지만 process는 init프로세스를 root로 하는 거대한 하나의 트리지만 cgroups는 하나 이상의 분리된 hierarchy를 가집니다. 규칙 cgroups에는 규칙이 4가지 있습니다. 각 규칙은 다음과 같습니다. 규칙 1 각 hierarchy는 하나 이상의 subsystem들을 가질 수 있습니다. 규칙 2 한 subsystem이 연결하려는 hierarchy들이 이미 다른 subsystem을 가지고 있다면 둘 이상의 다른 hierarchy에 연결할 수 없습니다.(그 중 하나에만 연결할 수 있습니다.) 하지만 연결하려는 hierarchy들이 subsystem으로 자신 하나만 가진다면 여러 hierarchy에 연결할 수 있습니다. 규칙 3 각 task들은 여러 cgroup에 속할 수 있지만 한 hierarchy 내에서는 하나의 cgroup에만 속해야 합니다. 또한 모든 system task는 항상 적어도 하나의 cgroup에 속합니다. 규칙 4 항상 child task는 parent task의 cgroup을 상속받아 초기화됩니다. 하지만 parent와 child는 독립적이기 때문에 이후에 바뀔 수 있습니다. 기본적인 사용법 가장 기본적인 사용법은 다음과 같습니다. mount -t tmpfs &amp;lt;cgroup_root&amp;gt; &amp;lt;path&amp;gt;: cgroup_root라는 이름으로 path를 tmpfs마운트 합니다. 이곳이 hierarchy들을 담을 장소가 됩니다. mount -t cgroup -o &amp;lt;comma_separated_subsystem_names&amp;gt; &amp;lt;path&amp;gt;: path에 subsystem들을 마운트합니다. path폴더가 하나의 cgroup이 됩니다. cgroup의 폴더 안에 있는 파일 중 task파일 안에 원하는 프로세스 PID를 적어주면 됩니다. 하지만 이런 방법으로는 실제 사용하기가 매우 힘듭니다. 다음 게시글에서 실제 사용법을 알아보겠습니다. Reference kernel.org redhat 7 redhat 6</summary></entry><entry><title type="html">IT 구직시 팁들</title><link href="http://ryul99.github.io/2019/06/14/Finding-Job-Tips.html" rel="alternate" type="text/html" title="IT 구직시 팁들" /><published>2019-06-14T00:00:00+09:00</published><updated>2019-06-14T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/06/14/Finding-Job-Tips</id><content type="html" xml:base="http://ryul99.github.io/2019/06/14/Finding-Job-Tips.html">&lt;p&gt;줄이고 있는 추세긴 하지만 IT계열에 관심 있는 많은 학생들이 IT병역특례를 지원하고 있습니다. IT병역특례를 하려고 찾고 있거나 구직을 처음 하는 사람들을 위한 팁을 남겨 봅니다. 여기서 언급되는 구인구직이 아닌 병역 관련 정보들은 언제든지 바뀔 수 있습니다. 병역 관련 정보들은 쉽게 바뀌기 때문에 병무청이 올리는 공지나 기타 정보들을 최대한 수집하고 관심을 기울이셔야 합니다. 여기서 언급되는 병특 관련 정보들은 모두 2019년 6월 기준 정보들입니다. 여기서 언급하는 구인구직 팁들은 공채가 아닌 중소기업(스타트업) 상시채용 기준입니다.&lt;/p&gt;

&lt;h1 id=&quot;현역이라면-연초에-병특-회사를-찾아야-합니다&quot;&gt;현역이라면 연초에 병특 회사를 찾아야 합니다&lt;/h1&gt;
&lt;p&gt;2019년 기준으로 현역은 TO가 있는 회사를 찾아서 들어가야 합니다. 일반적으로 TO를 받는 회사들이 있고 이는 병무청에서 알 수 있는데 문제는 이 TO가 연초에 거의 다 동납니다. 실제 현역 재배정 TO는 연말에 결정되지만 연초에 회사에서 TO제공을 약속받고 들어가는 사람들이 많기 때문입니다. 때문에 최대한 빨리, 연초에 병특 회사를 찾아야 합니다.
보충역이라면 언제 회사를 찾던지 상관없습니다. 보충역의 경우 회사마다 정해진 TO가 없고 심지어 병특 시작도 원하는 시기에 할 수 있습니다.&lt;/p&gt;

&lt;h1 id=&quot;면접에서는-아는-것을-최대한-많이-말하세요&quot;&gt;면접에서는 아는 것을 최대한 많이 말하세요&lt;/h1&gt;
&lt;p&gt;기술면접은 일반적으로 프레임워크, 자료구조 등등의 기술적인 질문들을 받고 답하는 자리입니다. 질문들의 답들을 알면 대답하시면 되지만 사람인 이상 모를 수도 있습니다. 그럴 경우 거리낌 없이 면접관에게 문제에 대해 질문하거나 여러분이 아는 관련된 다른 내용을 말하겠다고 한 후 말하세요. 자신이 아는 것을 최대한 자랑하세요&lt;/p&gt;

&lt;h1 id=&quot;최대한-많은-회사를-지원하세요&quot;&gt;최대한 많은 회사를 지원하세요&lt;/h1&gt;
&lt;p&gt;말 그대로입니다. 회사들을 최대한 많이 지원하세요. 이는 연봉협상에 유리하기 때문입니다. 합격한 회사들은 일종의 카드입니다. 이 회사는 얼마 주더라, 저 회사는 얼마 주더라 하면서 자신의 몸값을 높일 수 있는 카드고 그렇게 하셔야 합니다. 회사는 당신에게 천만 원 2천만 원 더 준다고 망하지 않습니다. 좋은 회사들을, 최대한 많이 붙으시고 안 좋은 회사더라도 일단 붙으시고 다른 회사 연봉협상에 카드로 사용하신 후 안 가시면 됩니다. 회사에서 다른 회사에 붙은 곳이 있는지 물어보는 경우가 있습니다. 혹시라도 붙은 곳이 없거나 연봉을 잘 주는, 혹은 좋은 회사를 붙은 곳이 없다면 대답 안 하셔도 됩니다. 자신의 손패를 상대에게 다 보여줄 필요는 없습니다.&lt;/p&gt;

&lt;h1 id=&quot;연봉은-협상자리에서-결정할-필요가-없습니다&quot;&gt;연봉은 협상자리에서 결정할 필요가 없습니다&lt;/h1&gt;
&lt;p&gt;회사에 붙으셨다면 연봉협상을 하게 됩니다. 구직을 처음 하는 사람에게는 연봉협상 자리에서 바로 연봉을 땅땅땅하고 결정해야 할 것 같습니다. 하지만 전혀 그렇지 않습니다. 연봉은 협상자리가 끝나도 확정만 안 지으면 어느 정도 시간 안에는 바꿀 수 있습니다.
또한 연봉은 특정 금액을 정해서 말하는 것보다 금액의 범위를 말하는 것이 좋으며 어차피 회사에 의해 깎이므로 어느 정도 높게 불러도 됩니다. 연봉협상(임원면접)에서 조심해야 할 것은 할 말은 다 하면서 상대방의 기분을 좋게 해야 한다는 것입니다. 임원들은 말 그대로 여러분의 연봉을 더 높일 수도 낮출 수도 있는 사람입니다. 할 말은 다 하되 기분 나쁘게 하지는 마세요&lt;/p&gt;

&lt;h1 id=&quot;연락을-하세요&quot;&gt;연락을 하세요&lt;/h1&gt;
&lt;p&gt;지원 후에 회사에서 연락이 늦어지는 경우가 있습니다. 공채가 아니기 때문에 일반적으로 회사가 사람을 탈락시킬 때에는 연락을 주고 안 주면 저희가 연락을 해서 알아내야 합니다. 지원 후에 회사로부터 연락이 없다고 탈락했다고 생각하지 마시고 꼭 회사에 입사 전형이 진행되고 있는지 연락을 하셔야 합니다. 대부분의 경우는 회사가 바빠서, 혹은 다른 일 때문에 정신이 없어서 까먹고 연락을 못 주고 있는 경우입니다. 때문에 회사에서 연락이 늦으면 꼭 회사와 연락해서 진행되고 있는지 확인하셔야 합니다. 제 기준으로 연락이 늦는 것은 5영업일, 일주일 정도입니다.&lt;br /&gt;
병특회사 중에는 탈락 시에 왜 탈락했는지 물어보면 이유를 알려주는 회사도 있습니다. 탈락이유를 아는 것은 지원자 입장에서 거부할 이유가 없습니다. 가능하다면 물어보세요.&lt;/p&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="Jobs" /><category term="병특" /><summary type="html">줄이고 있는 추세긴 하지만 IT계열에 관심 있는 많은 학생들이 IT병역특례를 지원하고 있습니다. IT병역특례를 하려고 찾고 있거나 구직을 처음 하는 사람들을 위한 팁을 남겨 봅니다. 여기서 언급되는 구인구직이 아닌 병역 관련 정보들은 언제든지 바뀔 수 있습니다. 병역 관련 정보들은 쉽게 바뀌기 때문에 병무청이 올리는 공지나 기타 정보들을 최대한 수집하고 관심을 기울이셔야 합니다. 여기서 언급되는 병특 관련 정보들은 모두 2019년 6월 기준 정보들입니다. 여기서 언급하는 구인구직 팁들은 공채가 아닌 중소기업(스타트업) 상시채용 기준입니다. 현역이라면 연초에 병특 회사를 찾아야 합니다 2019년 기준으로 현역은 TO가 있는 회사를 찾아서 들어가야 합니다. 일반적으로 TO를 받는 회사들이 있고 이는 병무청에서 알 수 있는데 문제는 이 TO가 연초에 거의 다 동납니다. 실제 현역 재배정 TO는 연말에 결정되지만 연초에 회사에서 TO제공을 약속받고 들어가는 사람들이 많기 때문입니다. 때문에 최대한 빨리, 연초에 병특 회사를 찾아야 합니다. 보충역이라면 언제 회사를 찾던지 상관없습니다. 보충역의 경우 회사마다 정해진 TO가 없고 심지어 병특 시작도 원하는 시기에 할 수 있습니다. 면접에서는 아는 것을 최대한 많이 말하세요 기술면접은 일반적으로 프레임워크, 자료구조 등등의 기술적인 질문들을 받고 답하는 자리입니다. 질문들의 답들을 알면 대답하시면 되지만 사람인 이상 모를 수도 있습니다. 그럴 경우 거리낌 없이 면접관에게 문제에 대해 질문하거나 여러분이 아는 관련된 다른 내용을 말하겠다고 한 후 말하세요. 자신이 아는 것을 최대한 자랑하세요 최대한 많은 회사를 지원하세요 말 그대로입니다. 회사들을 최대한 많이 지원하세요. 이는 연봉협상에 유리하기 때문입니다. 합격한 회사들은 일종의 카드입니다. 이 회사는 얼마 주더라, 저 회사는 얼마 주더라 하면서 자신의 몸값을 높일 수 있는 카드고 그렇게 하셔야 합니다. 회사는 당신에게 천만 원 2천만 원 더 준다고 망하지 않습니다. 좋은 회사들을, 최대한 많이 붙으시고 안 좋은 회사더라도 일단 붙으시고 다른 회사 연봉협상에 카드로 사용하신 후 안 가시면 됩니다. 회사에서 다른 회사에 붙은 곳이 있는지 물어보는 경우가 있습니다. 혹시라도 붙은 곳이 없거나 연봉을 잘 주는, 혹은 좋은 회사를 붙은 곳이 없다면 대답 안 하셔도 됩니다. 자신의 손패를 상대에게 다 보여줄 필요는 없습니다. 연봉은 협상자리에서 결정할 필요가 없습니다 회사에 붙으셨다면 연봉협상을 하게 됩니다. 구직을 처음 하는 사람에게는 연봉협상 자리에서 바로 연봉을 땅땅땅하고 결정해야 할 것 같습니다. 하지만 전혀 그렇지 않습니다. 연봉은 협상자리가 끝나도 확정만 안 지으면 어느 정도 시간 안에는 바꿀 수 있습니다. 또한 연봉은 특정 금액을 정해서 말하는 것보다 금액의 범위를 말하는 것이 좋으며 어차피 회사에 의해 깎이므로 어느 정도 높게 불러도 됩니다. 연봉협상(임원면접)에서 조심해야 할 것은 할 말은 다 하면서 상대방의 기분을 좋게 해야 한다는 것입니다. 임원들은 말 그대로 여러분의 연봉을 더 높일 수도 낮출 수도 있는 사람입니다. 할 말은 다 하되 기분 나쁘게 하지는 마세요 연락을 하세요 지원 후에 회사에서 연락이 늦어지는 경우가 있습니다. 공채가 아니기 때문에 일반적으로 회사가 사람을 탈락시킬 때에는 연락을 주고 안 주면 저희가 연락을 해서 알아내야 합니다. 지원 후에 회사로부터 연락이 없다고 탈락했다고 생각하지 마시고 꼭 회사에 입사 전형이 진행되고 있는지 연락을 하셔야 합니다. 대부분의 경우는 회사가 바빠서, 혹은 다른 일 때문에 정신이 없어서 까먹고 연락을 못 주고 있는 경우입니다. 때문에 회사에서 연락이 늦으면 꼭 회사와 연락해서 진행되고 있는지 확인하셔야 합니다. 제 기준으로 연락이 늦는 것은 5영업일, 일주일 정도입니다. 병특회사 중에는 탈락 시에 왜 탈락했는지 물어보면 이유를 알려주는 회사도 있습니다. 탈락이유를 아는 것은 지원자 입장에서 거부할 이유가 없습니다. 가능하다면 물어보세요.</summary></entry><entry><title type="html">Github Pages deploy</title><link href="http://ryul99.github.io/2019/06/09/Github-Pages-deploy.html" rel="alternate" type="text/html" title="Github Pages deploy" /><published>2019-06-09T00:00:00+09:00</published><updated>2019-06-09T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/06/09/Github-Pages-deploy</id><content type="html" xml:base="http://ryul99.github.io/2019/06/09/Github-Pages-deploy.html">&lt;p&gt;Github Pages는 지원되는 jekyll plugin이 정해져 있습니다. (&lt;a href=&quot;https://pages.github.com/versions/&quot;&gt;여기&lt;/a&gt;에서 확인할 수 있습니다.) 때문에 깃헙에서 지원되지 않는 jekyll plugin을 사용하려면 jekyll 소스코드를 build 하는 것이 아니라 빌드된 결과물을 서빙해야 합니다. 이번에는 이 방법을 몇 가지 정리해보려 합니다.&lt;/p&gt;

&lt;h1 id=&quot;subtree&quot;&gt;subtree&lt;/h1&gt;
&lt;p&gt;git subtree는 기본적으로 하나의 깃 레포 안에 다른 깃 레포가 포함되어 있는 형태입니다. 다만, subtree의 경우 포함되어 있는 하위 레포는 포함하고 있는 상위 레포에 의해 버전 관리가 이루어지고 이렇게 관리된 버전을 하위 폴더의 remote에 push 혹은 pull 하기만 할 뿐입니다. Workflow는 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git subtree add --prefix {local subdirectory} {remote repo} {remote branch}&lt;/code&gt; 를 통해서 local subdirectory의 위치에 remote repo의 remote branch에서 clone 받습니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git subtree [pull/push] --prefix {local subdirectory} {remote repo} {remote branch}&lt;/code&gt; 를 통해서 local subdirectory를 pull / push 할 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Github Page에서 이를 활용하는 방법은 remote에 build 된 결과물을 두는 브랜치를 따로 두고 이를 subtree로 사용하는 방법입니다. 저는 master를 deploy브랜치, source를 소스코드 브랜치로 두고 있습니다.
조심해야 할 점은 local subdirectory에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;..&lt;/code&gt;을 사용하면 안된다는 점입니다.&lt;/p&gt;

&lt;h1 id=&quot;orphan-branch&quot;&gt;orphan branch&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout --orphan {new branch}&lt;/code&gt;를 하면 어떤 커밋도 없는 브랜치가 new branch라는 명칭으로 생깁니다. 이를 활용해서 새로 만든 브랜치에 build 된 결과물을 두고 이 브랜치를 기준으로 deploy 하면 됩니다. subtree와 비교해보면 이 방법은  소스코드와 결과물의 버전 관리를 각각 하게 되고 빌드한 결과물을 빼내서 다른 곳에 둔 후 checkout 한 후 다시 결과물을 넣어줘야 한다는 특징이 있습니다.&lt;/p&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="github" /><summary type="html">Github Pages는 지원되는 jekyll plugin이 정해져 있습니다. (여기에서 확인할 수 있습니다.) 때문에 깃헙에서 지원되지 않는 jekyll plugin을 사용하려면 jekyll 소스코드를 build 하는 것이 아니라 빌드된 결과물을 서빙해야 합니다. 이번에는 이 방법을 몇 가지 정리해보려 합니다. subtree git subtree는 기본적으로 하나의 깃 레포 안에 다른 깃 레포가 포함되어 있는 형태입니다. 다만, subtree의 경우 포함되어 있는 하위 레포는 포함하고 있는 상위 레포에 의해 버전 관리가 이루어지고 이렇게 관리된 버전을 하위 폴더의 remote에 push 혹은 pull 하기만 할 뿐입니다. Workflow는 다음과 같습니다. git subtree add --prefix {local subdirectory} {remote repo} {remote branch} 를 통해서 local subdirectory의 위치에 remote repo의 remote branch에서 clone 받습니다. git subtree [pull/push] --prefix {local subdirectory} {remote repo} {remote branch} 를 통해서 local subdirectory를 pull / push 할 수 있습니다. Github Page에서 이를 활용하는 방법은 remote에 build 된 결과물을 두는 브랜치를 따로 두고 이를 subtree로 사용하는 방법입니다. 저는 master를 deploy브랜치, source를 소스코드 브랜치로 두고 있습니다. 조심해야 할 점은 local subdirectory에서 .이나 ..을 사용하면 안된다는 점입니다. orphan branch git checkout --orphan {new branch}를 하면 어떤 커밋도 없는 브랜치가 new branch라는 명칭으로 생깁니다. 이를 활용해서 새로 만든 브랜치에 build 된 결과물을 두고 이 브랜치를 기준으로 deploy 하면 됩니다. subtree와 비교해보면 이 방법은 소스코드와 결과물의 버전 관리를 각각 하게 되고 빌드한 결과물을 빼내서 다른 곳에 둔 후 checkout 한 후 다시 결과물을 넣어줘야 한다는 특징이 있습니다.</summary></entry><entry><title type="html">Github Pages에 구글 애드센스 달기</title><link href="http://ryul99.github.io/2019/05/30/Github-Pages-Adsense.html" rel="alternate" type="text/html" title="Github Pages에 구글 애드센스 달기" /><published>2019-05-30T00:00:00+09:00</published><updated>2019-05-30T00:00:00+09:00</updated><id>http://ryul99.github.io/2019/05/30/Github-Pages-Adsense</id><content type="html" xml:base="http://ryul99.github.io/2019/05/30/Github-Pages-Adsense.html">&lt;p&gt;첫 게시글! 삽질 정리를 위해 블로깅을 하기에 블로깅 하기 위해서 했던 삽질부터 올립니다.
저는 개인용으로 github pages를 처음 써서 이 블로그를 만들었습니다.&lt;/p&gt;

&lt;h1 id=&quot;문제의-시작&quot;&gt;문제의 시작…&lt;/h1&gt;
&lt;p&gt;처음에 제가 원했던 것은 마크다운 파일들만 정리해서 올리고 레포 세팅에서 테마 선택하는 것 정도로 간단하게 하는 것이었습니다.
문제는 구글 애드센스와 구글 애널리틱스 삽입..
결론부터 말하자면 &lt;strong&gt;깃헙 세팅에서 테마 선택하는 거로는 애드센스와 애널리틱스 적용이 안되더군요&lt;/strong&gt;
하지만 생각보다 애드센스와 애널리틱스 적용하는 게 어렵지는 않습니다.&lt;/p&gt;

&lt;h1 id=&quot;테마-가져오기&quot;&gt;테마 가져오기&lt;/h1&gt;
&lt;p&gt;애드센스와 애널리틱스를 적용하려면 직접 테마를 자신의 github page 레포에 가져와서 적용을 해야 합니다.
찾아보니 github page는 기본적으로 Jekyll이라는 것으로 돌아가고 있고 깃헙 세팅에서 테마를 선택하는 것도 이 Jekyll 테마를 자동으로 적용해주는 것입니다.
&lt;a href=&quot;github help&quot;&gt;github help&lt;/a&gt;를 참고해보면 깃헙에서 제공하는 Jekyll 테마는 &lt;a href=&quot;https://github.com/pages-themes/&quot;&gt;여기&lt;/a&gt;에서 확인할 수 있다는 것을 알 수 있습니다.
깃헙에서 제공되는 Jekyll 테마 외에도 Jekyll 테마는 다양한 테마가 있는데 이 들을 자신의 레포로 가져오면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;jekyll-설명&quot;&gt;Jekyll 설명&lt;/h2&gt;
&lt;p&gt;이렇게 가져온 Jekyll 테마들을 사용하기 위해서 간단히 Jekyll에 대해서 알아봅시다. (저도 Jekyll에 대해서 확실히 아는 것은 아니고 삽질하면서 배운 정도가 다이니 너무 맹신하지는 말아주세요)
먼저 중요하게 보셔야 할 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;입니다. 사이트의 설정들을 담고 있는 듯한데 뒤에서 설명할 &lt;code class=&quot;highlighter-rouge&quot;&gt;_includes&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;폴더 안의 html 파일들을 보면 이 파일에서 변수를 가져와서 렌더링 하는 부분이 있을 수 있습니다. 때문에 가져오신 테마의 &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;를 잘 이해하시고 설정해주셔야 합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;_includes&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;는 실제 html를 담고 있습니다. 보통 &lt;code class=&quot;highlighter-rouge&quot;&gt;_includes&lt;/code&gt;에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;에서 사용할 코드들을 조각조각으로 가지고 있고 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;에 있는 파일들을 이용해서 페이지를 렌더링 할 수 있습니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt;에는 말 그대로 블로그의 글들이 담기게 됩니다. 여기에 담기는 파일들의 양식은 &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-title.md&lt;/code&gt;이런 식으로 담기고 이 파일의 맨 위에 &lt;code class=&quot;highlighter-rouge&quot;&gt;---&lt;/code&gt;로 감싼 부분(front matter)에서 layout과 다른 설정들을 정할 수 있습니다.
예를 들어&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
layout: post
title:  &quot;Github Pages에 구글 애드센스 달기&quot;
date:   2019-05-30 11:43:59 +0900
author: ryul99
categories: 삽질
tags:	github adsense
---
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;라고 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;에 저장된 post.html이 적용되어 나오게 됩니다.&lt;/p&gt;

&lt;h1 id=&quot;애드센스애널리틱스의-코드-스니펫-추가하기&quot;&gt;애드센스/애널리틱스의 코드 스니펫 추가하기&lt;/h1&gt;
&lt;p&gt;이제 마지막으로 애드센스/애널리틱스에서 준 코드 스니펫을 추가하면 됩니다!
실제 사용되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;의 파일이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;에서 사용되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;_includes&lt;/code&gt;의 파일에 추가하시면 됩니다.
제가 추가했던 커밋은 &lt;a href=&quot;https://github.com/ryul99/ryul99.github.io/commit/2c77701489c15aa6de77a1eaf3d07784359ee80b&quot;&gt;여기서&lt;/a&gt; 확인하실 수 있으니 함께 참고하시면 좋을 듯합니다.&lt;/p&gt;</content><author><name>Changmin Choi</name><email>cmchoi9901@gmail.com</email></author><category term="github" /><category term="adsense" /><summary type="html">첫 게시글! 삽질 정리를 위해 블로깅을 하기에 블로깅 하기 위해서 했던 삽질부터 올립니다. 저는 개인용으로 github pages를 처음 써서 이 블로그를 만들었습니다. 문제의 시작… 처음에 제가 원했던 것은 마크다운 파일들만 정리해서 올리고 레포 세팅에서 테마 선택하는 것 정도로 간단하게 하는 것이었습니다. 문제는 구글 애드센스와 구글 애널리틱스 삽입.. 결론부터 말하자면 깃헙 세팅에서 테마 선택하는 거로는 애드센스와 애널리틱스 적용이 안되더군요 하지만 생각보다 애드센스와 애널리틱스 적용하는 게 어렵지는 않습니다. 테마 가져오기 애드센스와 애널리틱스를 적용하려면 직접 테마를 자신의 github page 레포에 가져와서 적용을 해야 합니다. 찾아보니 github page는 기본적으로 Jekyll이라는 것으로 돌아가고 있고 깃헙 세팅에서 테마를 선택하는 것도 이 Jekyll 테마를 자동으로 적용해주는 것입니다. github help를 참고해보면 깃헙에서 제공하는 Jekyll 테마는 여기에서 확인할 수 있다는 것을 알 수 있습니다. 깃헙에서 제공되는 Jekyll 테마 외에도 Jekyll 테마는 다양한 테마가 있는데 이 들을 자신의 레포로 가져오면 됩니다. Jekyll 설명 이렇게 가져온 Jekyll 테마들을 사용하기 위해서 간단히 Jekyll에 대해서 알아봅시다. (저도 Jekyll에 대해서 확실히 아는 것은 아니고 삽질하면서 배운 정도가 다이니 너무 맹신하지는 말아주세요) 먼저 중요하게 보셔야 할 것이 _config.yml입니다. 사이트의 설정들을 담고 있는 듯한데 뒤에서 설명할 _includes나 _layouts폴더 안의 html 파일들을 보면 이 파일에서 변수를 가져와서 렌더링 하는 부분이 있을 수 있습니다. 때문에 가져오신 테마의 _config.yml를 잘 이해하시고 설정해주셔야 합니다. _includes와 _layouts는 실제 html를 담고 있습니다. 보통 _includes에는 _layouts에서 사용할 코드들을 조각조각으로 가지고 있고 _layouts에 있는 파일들을 이용해서 페이지를 렌더링 할 수 있습니다. _post에는 말 그대로 블로그의 글들이 담기게 됩니다. 여기에 담기는 파일들의 양식은 YYYY-MM-DD-title.md이런 식으로 담기고 이 파일의 맨 위에 ---로 감싼 부분(front matter)에서 layout과 다른 설정들을 정할 수 있습니다. 예를 들어 --- layout: post title: &quot;Github Pages에 구글 애드센스 달기&quot; date: 2019-05-30 11:43:59 +0900 author: ryul99 categories: 삽질 tags: github adsense --- 라고 하면 _layouts에 저장된 post.html이 적용되어 나오게 됩니다. 애드센스/애널리틱스의 코드 스니펫 추가하기 이제 마지막으로 애드센스/애널리틱스에서 준 코드 스니펫을 추가하면 됩니다! 실제 사용되는 _layouts의 파일이나 _layouts에서 사용되는 _includes의 파일에 추가하시면 됩니다. 제가 추가했던 커밋은 여기서 확인하실 수 있으니 함께 참고하시면 좋을 듯합니다.</summary></entry></feed>